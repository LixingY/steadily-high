

# 04-14

### 1. 项目打包之后上线，存在缓存问题，该如何解决？

 ![1649924397(1)](images/1649924397(1).jpg)

  如图在每一个js后面加上自己定义的一个参数即可！  



# 04-15

### 2. Vue 与 React 区别？

- 相同点
  - 都支持服务器渲染
  - 都有虚拟 DOM，组件化开发，通过 `props` 参数进行父子组件数据的传递，都实现 `webcomponent` 规范
  - 都是数据驱动视图
  - 都有状态管理，React 有 `redux`；Vue 有 `vuex`
  - 都有支持 Native 的方案，React 有 `React Native`；vue 有 `Weex` 

- 不同点
  - React 严格上只针对 `MVC` 的 view 层；Vue 是 `MVVM` 模式
  - 虚拟 DOM 不一样。Vue 会跟踪每一个组件的依赖关系，不需要重新渲染整个 DOM 组件树；而 React 不同，当应用的状态被改变时，全部组件都会重新渲染，所以 React 中 用 `shouldcomponentupdate` 这个生命周期的钩子函数来控制
  - 组件写法不一样 。React 是 `JSX` 和 `inline style` ，就是把 `HTML `和 `CSS` 全写进 `JS` 中；Vue 则是 `HTML` 、` CSS` 和 `JS` 在同一个文件
  - 数据绑定不一样。Vue 实现了数据双向绑定，React 数据流动是单向的
    - 在 React 中，`state` 对象需要用 `setstate` 方法更新状态；而在 Vue 中，`state` 对象不是必须的，数据由 `data` 属性在 Vue 对象中管理



# 04-21

### 3. React Hook 防抖函数

```react
import React, { useState, useEffect, useRef, useCallback } from 'react';
import { AtSearchBar } from 'taro-ui'
 
export default () => {
  const [searchValue, setSearchValue] = useState('')
  // 防抖函数
  function useDebounce(fn, delay) {
    const { current } = useRef({ fn, timer: null });
    useEffect(function () {
      current.fn = fn;
    }, [current, fn]);
  
    // eslint-disable-next-line react-hooks/exhaustive-deps
    return useCallback(function f(...args) {
      // args[0].persist() 
      setSearchValue(args[0])
      if (current.timer) {
        clearTimeout(current.timer);
      }
      current.timer = setTimeout(() => {
        current.fn.call(this, ...args);
      }, delay);
    })
  }
  
  const onSearchChange = useDebounce(v=>{
      setSearchValue(v)
      productList()
   },800)
 
  return <AtSearchBar
     value={searchValue}
     placeholder='请输入客户名字'
     onChange={onSearchChange}
    />
    </div>
  </div>
}

```



# 04-24

### 4. react-hooks 如何动态修改列表的样式 点击变色

<img src="images/1650784194(1).jpg" alt="1650784194(1)" style="zoom:50%;" />

```react
let num = 0;
const handleClickItem = (itemId,isPackage,index) => {
    num = index 
    categoryData(itemId,isPackage)
}

<View>
   {
     itemList.map((item,index) =>{
         return (
             <View style={{backgroundColor:num === index ? '#fff' : '#ccc'}}
             key={index} onClick={()=>handleClickItem(item.standardItemId,'package',index)} 
             >{item.standardItemName}</View>
          )
       })
    }
</View> 

```



# 04-25

### 5. 用Taro开发的微信小程序 如何设置单个页面或者整个程序横屏

 (1) 单个页面：

  在单个页面的config.js中增加

```jsx
export default definePageConfig({
  navigationBarTitleText: '首页',
  pageOrientation: "landscape" //设置横屏
})
```

(2)整个小程序：

在app.config.js中增加

```jsx
export default defineAppConfig({
  window: {
    backgroundTextStyle: 'light',
    navigationBarBackgroundColor: '#fff',
    navigationBarTitleText: 'WeChat',
    navigationBarTextStyle: 'black',
    pageOrientation: "landscape" //设置横屏
  }
})

```

